name: GitFlow CI/CD Pipeline

on:
  push:
    branches: [ "main", "develop", "feature/*", "release/*", "hotfix/*" ]
    tags: [ "v*" ]
  pull_request:
    branches: [ "main", "develop" ]
  workflow_dispatch:

jobs:
  # ========================================================
  # STAGE 1: CI & Security (Runs on ALL branches)
  # ========================================================
  
  # Step 1: Build and Test
  build-and-test:
    name: Build and Test
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v4
    
    - name: Set up JDK 17
      uses: actions/setup-java@v4
      with:
        java-version: '17'
        distribution: 'temurin'
        cache: maven
    
    - name: Compile Code
      run: mvn clean compile
    
    - name: Run Unit Tests
      run: mvn test

  # Step 2: Security and Quality Analysis
  security-and-quality:
    name: Security & Quality Analysis
    runs-on: ubuntu-latest
    needs: build-and-test
    
    permissions:
      contents: read
      id-token: write

    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Full history for SonarQube
    
    - name: Set up JDK 17
      uses: actions/setup-java@v4
      with:
        java-version: '17'
        distribution: 'temurin'
        cache: maven

    # Trivy Filesystem Scan
    - name: Trivy Installation
      run: |
        sudo apt-get install -y wget apt-transport-https gnupg lsb-release
        wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
        echo deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main | sudo tee -a /etc/apt/sources.list.d/trivy.list
        sudo apt-get update -y
        sudo apt-get install -y trivy

    - name: Trivy FS Scan
      run: |
        trivy fs --format table .
        trivy fs --format json -o fs-report.json .

    # Gitleaks Secret Scanning
    - name: Gitleaks Installation
      run: |
        VERSION="8.18.2"
        wget https://github.com/gitleaks/gitleaks/releases/download/v${VERSION}/gitleaks_${VERSION}_linux_x64.tar.gz
        tar -zxvf gitleaks_${VERSION}_linux_x64.tar.gz
        sudo mv gitleaks /usr/local/bin/
    
    - name: Gitleaks Secret Scan
      run: gitleaks detect --source . --report-path gitleaks-report.json --report-format json --no-git || true

    # Snyk Dependency Scan
    - name: Install Snyk CLI
      run: |
        curl https://static.snyk.io/cli/latest/snyk-linux -o snyk
        chmod +x snyk
        sudo mv snyk /usr/local/bin/

    - name: Snyk Security Scan
      run: |
        chmod +x mvnw
        snyk test --all-projects --json-file-output=snyk-report.json || true
      env:
        SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}

    # Compile for SonarQube
    - name: Compile Code for SonarQube
      run: mvn clean compile
      continue-on-error: true
    
    # SonarQube Code Quality & Security
    - name: SonarQube Scan
      uses: SonarSource/sonarqube-scan-action@v5.0.0
      env:
        SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        SONAR_HOST_URL: ${{ vars.SONAR_HOST_URL }}
      continue-on-error: true
        
    - name: SonarQube Quality Gate Check
      id: sonarqube-quality-gate-check
      uses: sonarsource/sonarqube-quality-gate-action@master
      with:
        pollingTimeoutSec: 600
      env:
        SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        SONAR_HOST_URL: ${{ vars.SONAR_HOST_URL }}
      continue-on-error: true

    # Export SonarQube Results
    - name: Export SonarQube Results
      if: always()
      run: |
        curl -u "${{ secrets.SONAR_TOKEN }}:" \
          "${{ vars.SONAR_HOST_URL }}/api/issues/search?componentKeys=GC-Bank&severities=CRITICAL,BLOCKER,MAJOR&resolved=false" \
          -o sonarqube-export.json || echo "{}" > sonarqube-export.json
      continue-on-error: true

    # Configure AWS Credentials (for S3 upload)
    - name: Configure AWS Credentials
      if: always() && (github.ref == 'refs/heads/develop' || startsWith(github.ref, 'refs/heads/release/'))
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ vars.AWS_REGION }}
      continue-on-error: true

    # Upload Security Reports to S3
    - name: Upload Security Reports to S3
      if: always() && (github.ref == 'refs/heads/develop' || startsWith(github.ref, 'refs/heads/release/'))
      run: |
        # Generate date-based path
        DATE=$(date +%Y/%m/%d)
        RUN_ID="${{ github.run_number }}"
        COMMIT_SHA="${{ github.sha }}"
        BRANCH="${{ github.ref_name }}"
        TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)
        S3_BUCKET="${{ vars.S3_SECURITY_REPORTS_BUCKET }}"
        
        # Create metadata file
        cat > metadata.json <<EOF
        {
          "run_id": "${RUN_ID}",
          "commit_sha": "${COMMIT_SHA}",
          "branch": "${BRANCH}",
          "timestamp": "${TIMESTAMP}",
          "workflow": "${{ github.workflow }}",
          "actor": "${{ github.actor }}",
          "event": "${{ github.event_name }}",
          "reports": {
            "trivy": "trivy/${DATE}/run-${RUN_ID}/trivy-report.json",
            "snyk": "snyk/${DATE}/run-${RUN_ID}/snyk-report.json",
            "gitleaks": "gitleaks/${DATE}/run-${RUN_ID}/gitleaks-report.json",
            "sonarqube": "sonarqube/${DATE}/run-${RUN_ID}/sonarqube-export.json"
          }
        }
        EOF
        
        # Upload reports
        aws s3 cp fs-report.json s3://${S3_BUCKET}/trivy/${DATE}/run-${RUN_ID}/trivy-report.json --metadata "commit=${COMMIT_SHA},branch=${BRANCH},run=${RUN_ID}" || echo "âš ï¸ Trivy upload failed"
        aws s3 cp snyk-report.json s3://${S3_BUCKET}/snyk/${DATE}/run-${RUN_ID}/snyk-report.json --metadata "commit=${COMMIT_SHA},branch=${BRANCH},run=${RUN_ID}" || echo "âš ï¸ Snyk upload failed"
        aws s3 cp gitleaks-report.json s3://${S3_BUCKET}/gitleaks/${DATE}/run-${RUN_ID}/gitleaks-report.json --metadata "commit=${COMMIT_SHA},branch=${BRANCH},run=${RUN_ID}" || echo "âš ï¸ Gitleaks upload failed"
        aws s3 cp sonarqube-export.json s3://${S3_BUCKET}/sonarqube/${DATE}/run-${RUN_ID}/sonarqube-export.json --metadata "commit=${COMMIT_SHA},branch=${BRANCH},run=${RUN_ID}" || echo "âš ï¸ SonarQube upload failed"
        aws s3 cp metadata.json s3://${S3_BUCKET}/metadata/${DATE}/run-${RUN_ID}/metadata.json --metadata "commit=${COMMIT_SHA},branch=${BRANCH},run=${RUN_ID}" || echo "âš ï¸ Metadata upload failed"
      continue-on-error: true

    - name: Upload Security Reports to Artifacts
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: security-reports
        path: |
          fs-report.json
          gitleaks-report.json
          snyk-report.json
          sonarqube-export.json

  # AI Security Intelligence Analysis
  ai-security-intelligence:
    name: AI Security Intelligence
    runs-on: ubuntu-latest
    needs: security-and-quality
    if: always()
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Download Security Reports
      uses: actions/download-artifact@v4
      with:
        name: security-reports
        path: .

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.x'

    - name: Install Dependencies
      run: pip install requests boto3

    - name: Run AI Security Analysis (Current Scan)
      run: python scripts/ai_security_agent.py
      env:
        GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        GITHUB_STEP_SUMMARY: ${{ github.step_summary }}
        SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        SONAR_HOST_URL: ${{ vars.SONAR_HOST_URL }}
    
    - name: Configure AWS Credentials for Trend Analysis
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ vars.AWS_REGION }}
      continue-on-error: true
    
    - name: Run AI Trend Intelligence (Historical Analysis)
      if: github.ref == 'refs/heads/develop' || startsWith(github.ref, 'refs/heads/release/')
      run: python scripts/ai_trend_intelligence.py
      env:
        GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        AWS_REGION: ${{ vars.AWS_REGION }}
        S3_SECURITY_REPORTS_BUCKET: ${{ vars.S3_SECURITY_REPORTS_BUCKET }}
        GITHUB_STEP_SUMMARY: ${{ github.step_summary }}
      continue-on-error: true
    
    - name: Upload AI Reports
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: ai-reports
        path: |
          ai-trend-report.json

  # ========================================================
  # STAGE 2: Package Application
  # Runs on 'develop', 'release/*', and Tags
  # ========================================================
  package:
    name: Package Application
    runs-on: ubuntu-latest
    needs: ai-security-intelligence
    # Only run package/deploy steps on specific branches, not feature branches
    if: github.ref == 'refs/heads/develop' || startsWith(github.ref, 'refs/heads/release/') || startsWith(github.ref, 'refs/tags/v')
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up JDK 17
      uses: actions/setup-java@v4
      with:
        java-version: '17'
        distribution: 'temurin'
        cache: maven
    
    - name: Build JAR Package
      run: mvn package -DskipTests
    
    - name: Upload JAR Artifact
      uses: actions/upload-artifact@v4
      with:
        name: app-jar
        path: target/*.jar
        retention-days: 1

  # ========================================================
  # STAGE 3: Deploy to Environments
  # ========================================================

  # 3.1 Deploy to DEV (On push to 'develop')
  deploy-dev:
    name: Deploy to Dev
    runs-on: ubuntu-latest
    needs: package
    if: github.ref == 'refs/heads/develop'
    environment: development
    
    steps:
    - uses: actions/checkout@v4
    - uses: actions/download-artifact@v4
      with:
        name: app-jar
        path: target/
        
    - name: Configure AWS Credentials (Dev)
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }} # Dev Environment Secret
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ vars.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Build & Push Docker Image (Dev)
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: bankapp
        IMAGE_TAG: dev-${{ github.sha }}
      run: |
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        echo "Pushed: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"

    # ğŸ“¦ DAY 21 - TASK 21.2: Generate SBOM (Software Bill of Materials)
    # Creates a full "Ingredient List" of every library inside our Docker image
    # This is mandatory for Bank-level compliance (PCI-DSS, SOC2)
    - name: ğŸ“¦ Generate SBOM (Software Bill of Materials)
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: bankapp
        IMAGE_TAG: dev-${{ github.sha }}
      run: |
        echo "ğŸ” Scanning image for Software Bill of Materials..."
        trivy image \
          --format cyclonedx \
          --output sbom-dev.json \
          $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        echo "âœ… SBOM generated: sbom-dev.json"
        echo "ğŸ“¦ Total components found: $(cat sbom-dev.json | python3 -c "import json,sys; d=json.load(sys.stdin); print(len(d.get('components',[])))")"
      continue-on-error: true

    - name: ğŸ“¤ Upload SBOM as Compliance Artifact
      uses: actions/upload-artifact@v4
      with:
        name: sbom-dev-${{ github.sha }}
        path: sbom-dev.json
        retention-days: 90  # Keep for 90 days for compliance audits

    - name: Deploy to K8s (GitOps - Update Manifest Repo)
      env:
        MANIFEST_REPO: "https://x-access-token:${{ secrets.MANIFEST_REPO_TOKEN }}@github.com/Hadeedahmed254/client-devsecops-menifest.git"
        IMAGE_TAG: dev-${{ github.sha }}
      run: |
        echo "Updating manifest in GitOps Repo..."
        git clone $MANIFEST_REPO manifest-repo
        cd manifest-repo
        
        # Check if kustomization exists
        if [ ! -f overlays/dev/kustomization.yaml ]; then
          echo "Error: overlays/dev/kustomization.yaml not found!"
          exit 1
        fi

        # Update Image Tag using Kustomize (The God Level Way)
        cd overlays/dev
        kustomize edit set image bankapp:placeholder=${{ steps.login-ecr.outputs.registry }}/bankapp:$IMAGE_TAG
        
        # Commit and Push
        git config user.name "GitHub Actions"
        git config user.email "actions@github.com"
        git add kustomization.yaml
        git commit -m "chore(gitops): update dev image to $IMAGE_TAG" || echo "No changes to commit"
        git push
        echo "âœ… Manifest updated for Dev environment (Kustomize)."

  # 3.2 Deploy to PRE-PROD (On push to 'release/*')
  deploy-pre-prod:
    name: Deploy to Pre-Prod
    runs-on: ubuntu-latest
    needs: package
    if: startsWith(github.ref, 'refs/heads/release/')
    environment: pre-production
    
    steps:
    - uses: actions/checkout@v4
    - uses: actions/download-artifact@v4
      with:
        name: app-jar
        path: target/
        
    - name: Configure AWS Credentials (Pre-Prod)
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }} # Pre-Prod Environment Secret
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ vars.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Build & Push Docker Image (RC)
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: bankapp
        IMAGE_TAG: rc-${{ github.sha }}
      run: |
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        echo "Pushed: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"

    - name: Deploy to K8s (GitOps - Update Manifest Repo)
      env:
        MANIFEST_REPO: "https://x-access-token:${{ secrets.MANIFEST_REPO_TOKEN }}@github.com/Hadeedahmed254/client-devsecops-menifest.git"
        IMAGE_TAG: rc-${{ github.sha }}
      run: |
        echo "Updating manifest in GitOps Repo..."
        git clone $MANIFEST_REPO manifest-repo
        cd manifest-repo
        
        # Check if kustomization exists
        if [ ! -f overlays/pre-prod/kustomization.yaml ]; then
          echo "Error: overlays/pre-prod/kustomization.yaml not found!"
          exit 1
        fi

        # Update Image Tag using Kustomize
        cd overlays/pre-prod
        kustomize edit set image bankapp:placeholder=${{ steps.login-ecr.outputs.registry }}/bankapp:$IMAGE_TAG
        
        # Commit and Push
        git config user.name "GitHub Actions"
        git config user.email "actions@github.com"
        git add kustomization.yaml
        git commit -m "chore(gitops): update pre-prod image to $IMAGE_TAG" || echo "No changes to commit"
        git push
        echo "âœ… Manifest updated for Pre-Prod environment (Kustomize)."

    - name: ğŸ§ª Dynamic Smoke Test (Pre-Prod)
      run: |
        # 1. Wait for ArgoCD to detect the Git change and update the cluster pods
        echo "â³ Waiting 60s for ArgoCD eventual consistency..."
        sleep 60

        # 2. Update Kubeconfig so the runner can talk to the EKS API
        aws eks update-kubeconfig --name ${{ vars.EKS_CLUSTER_NAME }} --region ${{ vars.AWS_REGION }}

        # 3. Dynamically fetch the real Application Load Balancer (ALB) hostname from the Ingress object
        ALB_URL=$(kubectl get ingress bankapp-ingress -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')

        # 4. Trigger the external verification script against the live AWS endpoint
        chmod +x scripts/smoke-test.sh
        echo "ğŸš€ Testing real ALB URL: $ALB_URL"
        ./scripts/smoke-test.sh http://$ALB_URL

  # 3.3 Deploy to PROD (On Tag v*)
  deploy-prod:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: package
    if: startsWith(github.ref, 'refs/tags/v')
    environment: production # Requires Approval
    
    steps:
    - uses: actions/checkout@v4
    - uses: actions/download-artifact@v4
      with:
        name: app-jar
        path: target/
        
    - name: Configure AWS Credentials (Prod)
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }} # Prod Environment Secret
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ vars.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Build & Push Docker Image (Prod)
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: bankapp
        IMAGE_TAG: ${{ github.ref_name }} # e.g., v1.0.0
      run: |
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        # Also tag latest
        docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
        echo "Pushed: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"

    - name: Deploy to K8s (GitOps - Update Manifest Repo)
      env:
        MANIFEST_REPO: "https://x-access-token:${{ secrets.MANIFEST_REPO_TOKEN }}@github.com/Hadeedahmed254/client-devsecops-menifest.git"
        IMAGE_TAG: ${{ github.ref_name }}
      run: |
        echo "Updating manifest in GitOps Repo..."
        git clone $MANIFEST_REPO manifest-repo
        cd manifest-repo
        
        # Check if kustomization exists
        if [ ! -f overlays/prod/kustomization.yaml ]; then
          echo "Error: overlays/prod/kustomization.yaml not found!"
          exit 1
        fi

        # Update Image Tag using Kustomize
        cd overlays/prod
        kustomize edit set image bankapp:placeholder=${{ steps.login-ecr.outputs.registry }}/bankapp:$IMAGE_TAG
        
        # Commit and Push
        git config user.name "GitHub Actions"
        git config user.email "actions@github.com"
        git add kustomization.yaml
        git commit -m "chore(gitops): update prod image to $IMAGE_TAG" || echo "No changes to commit"
        git push
        echo "âœ… Manifest updated for Prod environment (Kustomize)."

    - name: ğŸ§ª Dynamic Smoke Test (Production)
      run: |
        # 1. Wait for ArgoCD to detect the Git change and promote the new version
        echo "â³ Waiting 60s for ArgoCD to sync the production state..."
        sleep 60

        # 2. Authenticate the runner with the Production EKS Cluster
        aws eks update-kubeconfig --name ${{ vars.EKS_CLUSTER_NAME }} --region ${{ vars.AWS_REGION }}

        # 3. Retrieve the dynamic Public DNS of the Production Application Load Balancer
        ALB_URL=$(kubectl get ingress bankapp-ingress -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')

        # 4. Execute the final business-level verification
        chmod +x scripts/smoke-test.sh
        echo "ğŸš€ Testing real Production ALB URL: $ALB_URL"
        ./scripts/smoke-test.sh http://$ALB_URL
