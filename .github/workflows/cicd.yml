name: GitFlow CI/CD Pipeline

on:
  push:
    branches: [ "main", "develop", "feature/*", "release/*", "hotfix/*" ]
    tags: [ "v*" ]
  pull_request:
    branches: [ "main", "develop" ]
  workflow_dispatch:

jobs:
  # ========================================================
  # STAGE 1: CI & Security (Runs on ALL branches)
  # ========================================================
  
  # Step 1: Build and Test
  build-and-test:
    name: Build and Test
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v4
    
    - name: Set up JDK 17
      uses: actions/setup-java@v4
      with:
        java-version: '17'
        distribution: 'temurin'
        cache: maven
    
    - name: Compile Code
      run: mvn clean compile
    
    - name: Run Unit Tests
      run: mvn test

  # Step 2: Security and Quality Analysis
  security-and-quality:
    name: Security & Quality Analysis
    runs-on: ubuntu-latest
    needs: build-and-test
    
    permissions:
      contents: read
      id-token: write

    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Full history for SonarQube
    
    - name: Set up JDK 17
      uses: actions/setup-java@v4
      with:
        java-version: '17'
        distribution: 'temurin'
        cache: maven

    # Trivy Filesystem Scan
    - name: Trivy Installation
      run: |
        sudo apt-get install -y wget apt-transport-https gnupg lsb-release
        wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
        echo deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main | sudo tee -a /etc/apt/sources.list.d/trivy.list
        sudo apt-get update -y
        sudo apt-get install -y trivy

    - name: Trivy FS Scan
      run: |
        trivy fs --format table .
        trivy fs --format json -o fs-report.json .

    # Gitleaks Secret Scanning
    - name: Gitleaks Installation
      run: |
        VERSION="8.18.2"
        wget https://github.com/gitleaks/gitleaks/releases/download/v${VERSION}/gitleaks_${VERSION}_linux_x64.tar.gz
        tar -zxvf gitleaks_${VERSION}_linux_x64.tar.gz
        sudo mv gitleaks /usr/local/bin/
    
    - name: Gitleaks Secret Scan
      run: gitleaks detect --source . --report-path gitleaks-report.json --report-format json --no-git || true

    # Snyk Dependency Scan
    - name: Install Snyk CLI
      run: |
        curl https://static.snyk.io/cli/latest/snyk-linux -o snyk
        chmod +x snyk
        sudo mv snyk /usr/local/bin/

    - name: Snyk Security Scan
      run: |
        chmod +x mvnw
        snyk test --all-projects --json-file-output=snyk-report.json || true
      env:
        SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}

    # Compile for SonarQube
    - name: Compile Code for SonarQube
      run: mvn clean compile
      continue-on-error: true
    
    # SonarQube Code Quality & Security
    - name: SonarQube Scan
      uses: SonarSource/sonarqube-scan-action@v5.0.0
      env:
        SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        SONAR_HOST_URL: ${{ vars.SONAR_HOST_URL }}
      continue-on-error: true
        
    - name: SonarQube Quality Gate Check
      id: sonarqube-quality-gate-check
      uses: sonarsource/sonarqube-quality-gate-action@master
      with:
        pollingTimeoutSec: 600
      env:
        SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        SONAR_HOST_URL: ${{ vars.SONAR_HOST_URL }}
      continue-on-error: true

    # Export SonarQube Results
    - name: Export SonarQube Results
      if: always()
      run: |
        curl -u "${{ secrets.SONAR_TOKEN }}:" \
          "${{ vars.SONAR_HOST_URL }}/api/issues/search?componentKeys=GC-Bank&severities=CRITICAL,BLOCKER,MAJOR&resolved=false" \
          -o sonarqube-export.json || echo "{}" > sonarqube-export.json
      continue-on-error: true

    # Configure AWS Credentials (for S3 upload)
    - name: Configure AWS Credentials
      if: always() && (github.ref == 'refs/heads/develop' || startsWith(github.ref, 'refs/heads/release/'))
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ vars.AWS_REGION }}
      continue-on-error: true

    # Upload Security Reports to S3
    - name: Upload Security Reports to S3
      if: always() && (github.ref == 'refs/heads/develop' || startsWith(github.ref, 'refs/heads/release/'))
      run: |
        # Generate date-based path
        DATE=$(date +%Y/%m/%d)
        RUN_ID="${{ github.run_number }}"
        COMMIT_SHA="${{ github.sha }}"
        BRANCH="${{ github.ref_name }}"
        TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)
        S3_BUCKET="${{ vars.S3_SECURITY_REPORTS_BUCKET }}"
        
        # Create metadata file
        cat > metadata.json <<EOF
        {
          "run_id": "${RUN_ID}",
          "commit_sha": "${COMMIT_SHA}",
          "branch": "${BRANCH}",
          "timestamp": "${TIMESTAMP}",
          "workflow": "${{ github.workflow }}",
          "actor": "${{ github.actor }}",
          "event": "${{ github.event_name }}",
          "reports": {
            "trivy": "trivy/${DATE}/run-${RUN_ID}/trivy-report.json",
            "snyk": "snyk/${DATE}/run-${RUN_ID}/snyk-report.json",
            "gitleaks": "gitleaks/${DATE}/run-${RUN_ID}/gitleaks-report.json",
            "sonarqube": "sonarqube/${DATE}/run-${RUN_ID}/sonarqube-export.json"
          }
        }
        EOF
        
        # Upload reports
        aws s3 cp fs-report.json s3://${S3_BUCKET}/trivy/${DATE}/run-${RUN_ID}/trivy-report.json --metadata "commit=${COMMIT_SHA},branch=${BRANCH},run=${RUN_ID}" || echo "⚠️ Trivy upload failed"
        aws s3 cp snyk-report.json s3://${S3_BUCKET}/snyk/${DATE}/run-${RUN_ID}/snyk-report.json --metadata "commit=${COMMIT_SHA},branch=${BRANCH},run=${RUN_ID}" || echo "⚠️ Snyk upload failed"
        aws s3 cp gitleaks-report.json s3://${S3_BUCKET}/gitleaks/${DATE}/run-${RUN_ID}/gitleaks-report.json --metadata "commit=${COMMIT_SHA},branch=${BRANCH},run=${RUN_ID}" || echo "⚠️ Gitleaks upload failed"
        aws s3 cp sonarqube-export.json s3://${S3_BUCKET}/sonarqube/${DATE}/run-${RUN_ID}/sonarqube-export.json --metadata "commit=${COMMIT_SHA},branch=${BRANCH},run=${RUN_ID}" || echo "⚠️ SonarQube upload failed"
        aws s3 cp metadata.json s3://${S3_BUCKET}/metadata/${DATE}/run-${RUN_ID}/metadata.json --metadata "commit=${COMMIT_SHA},branch=${BRANCH},run=${RUN_ID}" || echo "⚠️ Metadata upload failed"
      continue-on-error: true

    - name: Upload Security Reports to Artifacts
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: security-reports
        path: |
          fs-report.json
          gitleaks-report.json
          snyk-report.json
          sonarqube-export.json

  # AI Security Intelligence Analysis
  ai-security-intelligence:
    name: AI Security Intelligence
    runs-on: ubuntu-latest
    needs: security-and-quality
    if: always()
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Download Security Reports
      uses: actions/download-artifact@v4
      with:
        name: security-reports
        path: .

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.x'

    - name: Install Dependencies
      run: pip install requests boto3

    - name: Run AI Security Analysis (Current Scan)
      run: python scripts/ai_security_agent.py
      env:
        GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        GITHUB_STEP_SUMMARY: ${{ github.step_summary }}
        SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        SONAR_HOST_URL: ${{ vars.SONAR_HOST_URL }}
    
    - name: Configure AWS Credentials for Trend Analysis
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ vars.AWS_REGION }}
      continue-on-error: true
    
    - name: Run AI Trend Intelligence (Historical Analysis)
      if: github.ref == 'refs/heads/develop' || startsWith(github.ref, 'refs/heads/release/')
      run: python scripts/ai_trend_intelligence.py
      env:
        GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        AWS_REGION: ${{ vars.AWS_REGION }}
        S3_SECURITY_REPORTS_BUCKET: ${{ vars.S3_SECURITY_REPORTS_BUCKET }}
        GITHUB_STEP_SUMMARY: ${{ github.step_summary }}
      continue-on-error: true
    
    - name: Upload AI Reports
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: ai-reports
        path: |
          ai-trend-report.json

  # ========================================================
  # STAGE 2: Package Application
  # Runs on 'develop', 'release/*', and Tags
  # ========================================================
  package:
    name: Package Application
    runs-on: ubuntu-latest
    needs: ai-security-intelligence
    # Only run package/deploy steps on specific branches, not feature branches
    if: github.ref == 'refs/heads/develop' || startsWith(github.ref, 'refs/heads/release/') || startsWith(github.ref, 'refs/tags/v')
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up JDK 17
      uses: actions/setup-java@v4
      with:
        java-version: '17'
        distribution: 'temurin'
        cache: maven
    
    - name: Build JAR Package
      run: mvn package -DskipTests
    
    - name: Upload JAR Artifact
      uses: actions/upload-artifact@v4
      with:
        name: app-jar
        path: target/*.jar
        retention-days: 1

  # ========================================================
  # STAGE 3: Deploy to Environments
  # ========================================================

  # 3.1 Deploy to DEV (On push to 'develop')
  deploy-dev:
    name: Deploy to Dev
    runs-on: ubuntu-latest
    needs: package
    if: github.ref == 'refs/heads/develop'
    environment: development
    
    steps:
    - uses: actions/checkout@v4
    - uses: actions/download-artifact@v4
      with:
        name: app-jar
        path: target/
        
    - name: Configure AWS Credentials (Dev)
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }} # Dev Environment Secret
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ vars.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Build & Push Docker Image (Dev)
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: bankapp
        IMAGE_TAG: dev-${{ github.sha }}
      run: |
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        echo "Pushed: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"

    - name: Deploy to K8s (Dev Namespace)
      env:
        KUBE_CONFIG: ${{ secrets.KUBE_CONFIG }} # Dev Environment Secret
      run: |
        echo "Deploying to Kubernetes Namespace: dev"
        # kubectl apply -f k8s/ -n dev

  # 3.2 Deploy to PRE-PROD (On push to 'release/*')
  deploy-pre-prod:
    name: Deploy to Pre-Prod
    runs-on: ubuntu-latest
    needs: package
    if: startsWith(github.ref, 'refs/heads/release/')
    environment: pre-production
    
    steps:
    - uses: actions/checkout@v4
    - uses: actions/download-artifact@v4
      with:
        name: app-jar
        path: target/
        
    - name: Configure AWS Credentials (Pre-Prod)
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }} # Pre-Prod Environment Secret
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ vars.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Build & Push Docker Image (RC)
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: bankapp
        IMAGE_TAG: rc-${{ github.sha }}
      run: |
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        echo "Pushed: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"

    - name: Deploy to K8s (Pre-Prod Namespace)
      env:
        KUBE_CONFIG: ${{ secrets.KUBE_CONFIG }} # Pre-Prod Environment Secret
      run: |
        echo "Deploying to Kubernetes Namespace: pre-prod"
        # kubectl apply -f k8s/ -n pre-prod

  # 3.3 Deploy to PROD (On Tag v*)
  deploy-prod:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: package
    if: startsWith(github.ref, 'refs/tags/v')
    environment: production # Requires Approval
    
    steps:
    - uses: actions/checkout@v4
    - uses: actions/download-artifact@v4
      with:
        name: app-jar
        path: target/
        
    - name: Configure AWS Credentials (Prod)
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }} # Prod Environment Secret
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ vars.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Build & Push Docker Image (Prod)
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: bankapp
        IMAGE_TAG: ${{ github.ref_name }} # e.g., v1.0.0
      run: |
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        # Also tag latest
        docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
        echo "Pushed: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"

    - name: Deploy to K8s (Prod Namespace)
      env:
        KUBE_CONFIG: ${{ secrets.KUBE_CONFIG }} # Prod Environment Secret
      run: |
        echo "Deploying to Kubernetes Namespace: prod"
        # kubectl apply -f k8s/ -n prod
