1)Add Health Checks
Developer writes /health and /ready endpoints → Kubernetes monitors app health
I add .permitAll() in SecurityConfig → Kubernetes accesses without login
For testing: H2 in pom.xml (downloads library) + application.properties (configures it) → temporary, remove before production
I create production Dockerfile → multi-stage build, non-root user, optimized
Production: Remove H2, keep health endpoints + permitAll + Dockerfile → Kubernetes uses probes to auto-restart/route traffic

2) BRANCHING STRATEGY 
There is one main branch, it contains stable production code.
Develop branch is created from main, all current development happens here, not in main.
Developers create feature branches from develop (feature1, feature2, etc.).
Each developer works in their own feature branch.
When feature work is completed, they open a PR to merge feature into develop.
When feature branch is pushed, only CI runs (build, test, checks).
When PR is opened and merged into develop, CI runs and CD deploys to Dev environment.
Develop branch may be unstable because multiple features are combined there.
When features are complete and we want to prepare for release, we create a release branch from develop.
Release branch is used only for bug fixes and final testing (Pre-Prod environment). CI and CD both run and deploy to Pre-Prod.
When release is stable, it is merged into main branch.
When merged into main, CI and CD both run and deploy to Production.
Easy memory order:
feature → develop → release → main
Build → Combine → Stabilize → Launch



3) BRANCHING STRATEGY CODE
git checkout main
git checkout -b develop
git push -u origin develop

git checkout develop
git checkout -b feature/login
git push -u origin feature/login

git clone https://github.com/YourUsername/manifest-repo.git
cd manifest-repo
mkdir dev
mkdir pre-prod
mkdir prod
cp ../app-repo/ds.yml dev/deployment.yaml
cp ../app-repo/ds.yml pre-prod/deployment.yaml
cp ../app-repo/ds.yml prod/deployment.yaml
git add .
git commit -m "Initial GitOps structure"
git push origin main

git checkout develop
git merge feature/login
git push origin develop


git checkout develop
git pull origin develop
git checkout -b release/v1.0.0
git push -u origin release/v1.0.0


git checkout main
git pull origin main
git merge release/v1.0.0
git push origin main

git checkout develop
git merge --no-ff -m "Sync: Merge release/v1.0.0 back to develop [skip ci]" release/v1.0.0
git push origin develop


4) APP Monitoring Concept 
• Spring Boot Actuator adds internal endpoints like /health and /metrics to expose app status and performance
• Micrometer collects those metrics in a standard way inside the app
• Micrometer uses a registry to choose the monitoring system format (Prometheus, CloudWatch, etc.)
• With the Prometheus registry, metrics appear at /actuator/prometheus
• Prometheus scrapes that endpoint regularly
• Prometheus stores the data for graphs, alerts, and trend analysis

________>code for visualization
  <dependency> 
<groupId>io.micrometer</groupId> <artifactId>micrometer-registry-prometheus</artifactId> <scope>runtime</scope> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-actuator</artifactId> </dependency> 
management.endpoints.web.exposure.include=health,info,prometheus management.endpoint.prometheus.enabled=true management.metrics.export.prometheus.enabled=true


5) DB migration 
ddl-auto=update lets Hibernate automatically change the database structure.
This is dangerous in production because it can drop or alter important data accidentally.
Instead, we use Flyway to control database changes safely.
With Flyway, we write SQL files ourselves (e.g., V1__create_table.sql).
Each file represents a database version (V1, V2, V3…).
When the app starts, Flyway checks a table called flyway_schema_history.
If a version is already recorded there, Flyway skips it.
If a new version exists, Flyway runs it once and records it.
Flyway never guesses, never auto-drops columns — it only runs what YOU wrote.
Old migration files must never be edited; if you need changes, create a new version.

