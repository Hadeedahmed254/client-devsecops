1)Add Health Checks
Developer writes /health and /ready endpoints → Kubernetes monitors app health
I add .permitAll() in SecurityConfig → Kubernetes accesses without login
For testing: H2 in pom.xml (downloads library) + application.properties (configures it) → temporary, remove before production
I create production Dockerfile → multi-stage build, non-root user, optimized
Production: Remove H2, keep health endpoints + permitAll + Dockerfile → Kubernetes uses probes to auto-restart/route traffic

2) BRANCHING STRATEGY 
There is one main branch, it contains stable production code.
Develop branch is created from main, all current development happens here, not in main.
Developers create feature branches from develop (feature1, feature2, etc.).
Each developer works in their own feature branch.
When feature work is completed, they open a PR to merge feature into develop.
When feature branch is pushed, only CI runs (build, test, checks).
When PR is opened and merged into develop, CI runs and CD deploys to Dev environment.
Develop branch may be unstable because multiple features are combined there.
When features are complete and we want to prepare for release, we create a release branch from develop.
Release branch is used only for bug fixes and final testing (Pre-Prod environment). CI and CD both run and deploy to Pre-Prod.
When release is stable, it is merged into main branch.
When merged into main, CI and CD both run and deploy to Production.
Easy memory order:
feature → develop → release → main
Build → Combine → Stabilize → Launch



3) BRANCHING STRATEGY CODE
git checkout main
git checkout -b develop
git push -u origin develop

git checkout develop
git checkout -b feature/login
git push -u origin feature/login

git clone https://github.com/YourUsername/manifest-repo.git
cd manifest-repo
mkdir dev
mkdir pre-prod
mkdir prod
cp ../app-repo/ds.yml dev/deployment.yaml
cp ../app-repo/ds.yml pre-prod/deployment.yaml
cp ../app-repo/ds.yml prod/deployment.yaml
git add .
git commit -m "Initial GitOps structure"
git push origin main

git checkout develop
git merge feature/login
git push origin develop


git checkout develop
git pull origin develop
git checkout -b release/v1.0.0
git push -u origin release/v1.0.0


git checkout main
git pull origin main
git merge release/v1.0.0
git push origin main

git checkout develop
git merge --no-ff -m "Sync: Merge release/v1.0.0 back to develop [skip ci]" release/v1.0.0
git push origin develop


4) APP Monitoring Concept 
• Spring Boot Actuator adds internal endpoints like /health and /metrics to expose app status and performance
• Micrometer collects those metrics in a standard way inside the app
• Micrometer uses a registry to choose the monitoring system format (Prometheus, CloudWatch, etc.)
• With the Prometheus registry, metrics appear at /actuator/prometheus
• Prometheus scrapes that endpoint regularly
• Prometheus stores the data for graphs, alerts, and trend analysis

________>code for visualization
  <dependency> 
<groupId>io.micrometer</groupId> <artifactId>micrometer-registry-prometheus</artifactId> <scope>runtime</scope> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-actuator</artifactId> </dependency> 
management.endpoints.web.exposure.include=health,info,prometheus management.endpoint.prometheus.enabled=true management.metrics.export.prometheus.enabled=true


5) DB migration 
ddl-auto=update lets Hibernate automatically change the database structure.
This is dangerous in production because it can drop or alter important data accidentally.
Instead, we use Flyway to control database changes safely.
With Flyway, we write SQL files ourselves (e.g., V1__create_table.sql).
Each file represents a database version (V1, V2, V3…).
When the app starts, Flyway checks a table called flyway_schema_history.
If a version is already recorded there, Flyway skips it.
If a new version exists, Flyway runs it once and records it.
Flyway never guesses, never auto-drops columns — it only runs what YOU wrote.
Old migration files must never be edited; if you need changes, create a new version.

________>code for visualization
-- Create Account Table
CREATE TABLE IF NOT EXISTS account (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(255) NOT NULL,
    password VARCHAR(255) NOT NULL,
    balance DECIMAL(19,2),
    UNIQUE (username)
);

-- Create Transaction Table
CREATE TABLE IF NOT EXISTS transaction (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    amount DECIMAL(19,2),
    type VARCHAR(255),
    timestamp DATETIME(6),
    account_id BIGINT,
    FOREIGN KEY (account_id) REFERENCES account(id)
);

spring.jpa.hibernate.ddl-auto=validate
spring.flyway.enabled=true
spring.flyway.baseline-on-migrate=true

<dependency>
			<groupId>org.flywaydb</groupId>
			<artifactId>flyway-core</artifactId>
		</dependency>
		<dependency>
			<groupId>org.flywaydb</groupId>
			<artifactId>flyway-mysql</artifactId>
		</dependency>





6)NAT Restructuring.
Create VPC: The network boundary.
Create IGW (Internet Gateway): The physical exit to the internet.
Create 2 Public Subnets: One in AZ-1, One in AZ-2.
Create Public Route Table: Map 0.0.0.0/0 → IGW (Attach to Public Subnets).
Create 2 EIPs (Elastic IPs): Static public IPs.
Create 2 NAT Gateways: One per Public Subnet (for High Availability).
Create 2 Private Subnets: One in AZ-1, One in AZ-2.
Create 2 Private Route Tables:
Table 1: Map 0.0.0.0/0 → NAT Gateway 1 (Attach to Private Subnet 1).
Table 2: Map 0.0.0.0/0 → NAT Gateway 2 (Attach to Private Subnet 2).
Create EKS Cluster: Spanning all 4 subnets (Public+Private).
Create Node Group: Launch Worker Nodes inside ONLY the Private Subnets.

7)Gitops
Base contains the main application YAML that is the same for all environments.
Overlays only change what is different for each environment such as image tag, replicas, and labels.
The CI pipeline updates the image version inside the overlay instead of editing deployment files.
The updated overlay is committed to Git.
ArgoCD continuously watches the Git repository for changes.
When Git changes, ArgoCD runs Kustomize to merge the base and overlay into final Kubernetes manifests.
Kubernetes automatically updates to match what is stored in Git.
Base defines the application, overlay defines the environment, Git is the source of truth, and ArgoCD enforces it in the cluster.
If it is not in Git, it should not be running in Kubernetes.

8)HELM
Helm is a Kubernetes package manager that simplifies deploying and managing applications.

A Helm Chart is a packaged collection of Kubernetes manifests and configuration values that define an application.

Helm uses charts to install, upgrade, rollback, and version applications in a consistent way.